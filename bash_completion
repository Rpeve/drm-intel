#! /bin/bash

dim ()
{
	if [[ "x$1" = "xcd" ]]; then
		cd `cat ~/.dim-last-path`
	else
		command dim "$@"
	fi
}

_dim ()
{
	local cur cmds opts i
	local nightly_branches=`(source ~/linux/drm-intel-rerere/nightly.conf ; echo $nightly_branches) | \
		xargs -n 1 echo | grep '^origin' | sed -e 's/^origin\///'`
	local upstream_branches="origin/master airlied/drm-next airlied/drm-fixes"

	cmds="setup nightly-forget update-branches"
	cmds="$cmds rebuild-nightly cat-to-fixup"
	cmds="$cmds push-queued pq push-fixes push-next-fixes pnf push-branch"
	cmds="$cmds co cof conf"
	cmds="$cmds apply-branch ab sob apply-queued aq apply-fixes af apply-next-fixes anf"
	cmds="$cmds magic-patch mp cd"
	cmds="$cmds magic-rebase-resolve mrr"
	cmds="$cmds apply-igt ai"
	cmds="$cmds apply-resolved ar tc check-patch cp cherry-pick"
	cmds="$cmds pull-request pull-request-fixes pull-request-next pull-request-next-fixes"
	cmds="$cmds update-next"
	cmds="$cmds create-branch remove-branch create-workdir for-each-workdirs fw"
	cmds="$cmds tag-next checker"

	opts="-d -f -i"

	i=1

	COMPREPLY=()   # Array variable storing the possible completions.
	cur=${COMP_WORDS[COMP_CWORD]}

	for comp in "${COMP_WORDS[@]}" ; do
		for opt in $opts ; do
			if [[ $opt = $comp ]] ; then
				i=$((i+1))
			fi
		done
	done

	if [[ $COMP_CWORD == "$i" ]] ; then
		COMPREPLY=( $( compgen -W "$cmds $opts" -- $cur ) )
		return 0
	fi

	case "${COMP_WORDS[i]}" in
		push-branch)
			COMPREPLY=( $( compgen -W "-f $nightly_branches" -- $cur ) )
			;;
		push-queued|pq|push-fixes|pf|push-next-fixes|pnf)
			COMPREPLY=( $( compgen -W "-f" -- $cur ) )
			;;
		apply-branch|ab|sob)
			COMPREPLY=( $( compgen -W "-s $nightly_branches" -- $cur ) )
			;;
		apply-queued|aq|apply-fixes|af|apply-next-fixes|anf)
			COMPREPLY=( $( compgen -W "-s" -- $cur ) )
			;;
		magic-patch|mp)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -o nospace -W "-a" -- $cur ) )
			fi
			;;
		tc)
			# FIXME needs a git sha1
			;;
		check-patch|cp)
			# FIXME needs a git sha1
			;;
		pull-request)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -W "$nightly_branches" -- $cur ) )
			elif [[ $COMP_CWORD == "$((i+2))" ]] ; then
				COMPREPLY=( $( compgen -W "$upstream_branches" -- $cur ) )
			fi
			;;
		pull-request-next|pull-request-fixes|pull-request-next-fixes)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -W "$upstream_branches" -- $cur ) )
			fi
			;;
		create-branch)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -o nospace -W "drm- topic/" -- $cur ) )
			fi
			;;
		remove-branch)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -W "$nightly_branches" -- $cur ) )
			fi
			;;
		create-workdir)
			if [[ $COMP_CWORD == "$((i+1))" ]] ; then
				COMPREPLY=( $( compgen -W "$nightly_branches all" -- $cur ) )
			fi
			;;
	esac

	return 0
}
complete -F _dim dim

_qf ()
{
	local cur cmds

	cmds="setup checkout co rebase refresh clean-patches export export-visualize ev"
	cmds="$cmds push fetch pull stage wiggle-push resolved wp apply patch-amend pa"
	cmds="$cmds list-unused-patches baseline git g gitk k help"


	COMPREPLY=()   # Array variable storing the possible completions.
	cur=${COMP_WORDS[COMP_CWORD]}

	if [[ $COMP_CWORD == "1" ]] ; then
		COMPREPLY=( $( compgen -W "$cmds" -- $cur ) )
		return 0
	fi

	case "${COMP_WORDS[1]}" in
		pull)
			COMPREPLY=( $( compgen -W "--rebase" -- $cur ) )
			;;
	esac

	return 0
}
complete -F _qf qf
