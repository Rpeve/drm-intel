#! /bin/bash

dim ()
{
	if [[ "x$1" = "xcd" ]]; then
		cd `cat ~/.dim-last-path`
	else
		command dim "$@"
	fi
}

_dim ()
{
	local args arg cur prev words cword split
	local cmds

	# require bash-completion with _init_completion
	type -t _init_completion >/dev/null 2>&1 || return

	_init_completion || return

	COMPREPLY=()

	# arg = subcommand
	_get_first_arg

	# args = number of arguments
	_count_args

	if [ -f ~/linux/drm-intel-rerere/nightly.conf ] ; then
		local nightly_branches=`(source ~/linux/drm-intel-rerere/nightly.conf ; echo $nightly_branches) | \
			xargs -n 1 echo | grep '^origin' | sed -e 's/^origin\///'`
	else
		local nightly_branches=""
	fi
	local upstream_branches="origin/master airlied/drm-next airlied/drm-fixes"

	cmds="setup nightly-forget update-branches"
	cmds="$cmds rebuild-nightly cat-to-fixup"
	cmds="$cmds push-queued pq push-fixes pf push-next-fixes pnf push-branch"
	cmds="$cmds checkout co conq cof conf"
	cmds="$cmds apply-branch ab sob apply-queued aq apply-fixes af apply-next-fixes anf"
	cmds="$cmds magic-patch mp cd"
	cmds="$cmds magic-rebase-resolve mrr"
	cmds="$cmds apply-igt ai"
	cmds="$cmds apply-resolved ar tc fixes check-patch cp cherry-pick"
	cmds="$cmds pull-request pull-request-fixes pull-request-next pull-request-next-fixes"
	cmds="$cmds update-next"
	cmds="$cmds create-branch remove-branch create-workdir for-each-workdirs fw"
	cmds="$cmds tag-next checker"

	if [ -z "${arg}" ]; then
		# top level completion
		case "${cur}" in
			-*)
				local opts="-d -f -i"
				COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
				;;
			*)
				COMPREPLY=( $(compgen -W "${cmds}" -- ${cur}) )
				;;
		esac
		return 0
	fi

	case "${arg}" in
		push-branch)
			COMPREPLY=( $( compgen -W "-f $nightly_branches" -- $cur ) )
			;;
		push-queued|pq|push-fixes|pf|push-next-fixes|pnf)
			COMPREPLY=( $( compgen -W "-f" -- $cur ) )
			;;
		apply-branch|ab|sob)
			COMPREPLY=( $( compgen -W "-s $nightly_branches" -- $cur ) )
			;;
		apply-queued|aq|apply-fixes|af|apply-next-fixes|anf)
			COMPREPLY=( $( compgen -W "-s" -- $cur ) )
			;;
		magic-patch|mp)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -o nospace -W "-a" -- $cur ) )
			fi
			;;
		tc|fixes)
			# FIXME needs a git sha1
			;;
		check-patch|cp)
			# FIXME needs a git sha1
			;;
		pull-request)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -W "$nightly_branches" -- $cur ) )
			elif [[ $args == 3 ]]; then
				COMPREPLY=( $( compgen -W "$upstream_branches" -- $cur ) )
			fi
			;;
		pull-request-next|pull-request-fixes|pull-request-next-fixes)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -W "$upstream_branches" -- $cur ) )
			fi
			;;
		create-branch)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -o nospace -W "drm- topic/" -- $cur ) )
			fi
			;;
		checkout|co)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -W "$nightly_branches" -- $cur ) )
			fi
			;;
		remove-branch)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -W "$nightly_branches" -- $cur ) )
			fi
			;;
		create-workdir)
			if [[ $args == 2 ]]; then
				COMPREPLY=( $( compgen -W "$nightly_branches all" -- $cur ) )
			fi
			;;
	esac

	return 0
}
complete -F _dim dim

_qf ()
{
	local cur cmds

	cmds="setup checkout co rebase refresh clean-patches export export-visualize ev"
	cmds="$cmds push fetch pull stage wiggle-push resolved wp apply patch-amend pa"
	cmds="$cmds list-unused-patches baseline git g gitk k help"


	COMPREPLY=()   # Array variable storing the possible completions.
	cur=${COMP_WORDS[COMP_CWORD]}

	if [[ $COMP_CWORD == "1" ]] ; then
		COMPREPLY=( $( compgen -W "$cmds" -- $cur ) )
		return 0
	fi

	case "${COMP_WORDS[1]}" in
		pull)
			COMPREPLY=( $( compgen -W "--rebase" -- $cur ) )
			;;
	esac

	return 0
}
complete -F _qf qf
