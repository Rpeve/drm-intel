#!/bin/bash

# Copyright Â© 2012-2015 Intel Corporation
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Authors:
#    Daniel Vetter <daniel.vetter@ffwll.ch>

# drm-intel-next maintainer script

# TODO
# - extract the integration tree logic and make it generally useful, maybe for a
#   drm-integration tree ...
# - add a Link: tag referring to mid.mail-archive.com/<msg-id> to merged
#   patches
# - Improve nightly-forget to forget a specific merge instead of just the first
#   dinq/dif merge.
# - add option to check-patch to check stdin
# - fix up dim apply-patch to not apply the patch when checkpatch or the BUG_ON
#   scan fails
# - integrate ninja-check? Or too much checkers considered harmful?
#   https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2014-May/000554.html

# fail on any goof-up
set -e

#
# User configuration. Set in environment or configuration file. See
# dimrc.sample for an example.
#

# dim configuration file
DIM_CONFIG=${DIM_CONFIG:-$HOME/.dimrc}
if [ -r $DIM_CONFIG ]; then
    . $DIM_CONFIG
fi

# prefix for repo directories
DIM_PREFIX=${DIM_PREFIX:-$HOME/linux}

# main maintainer repo under $DIM_PREFIX
DIM_DRM_INTEL=${DIM_DRM_INTEL:-src}

# name of the $drm_intel_ssh remote within $DIM_DRM_INTEL
DIM_DRM_INTEL_REMOTE=${DIM_DRM_INTEL_REMOTE:-danvet}

# name of the $drm_upstream_git remote within $DIM_DRM_INTEL
DIM_DRM_UPSTREAM_REMOTE=${DIM_DRM_UPSTREAM_REMOTE:-airlied}

# mail user agent. must support a subset of mutt(1) command line options:
# usage: $DIM_MUA [-s subject] [-i file] [-c cc-addr] to-addr [...]
DIM_MUA=${DIM_MUA:-mutt}

# greetings pull request template
DIM_TEMPLATE_HELLO=${DIM_TEMPLATE_HELLO:-$HOME/.dim.template.hello}

# signature pull request template
DIM_TEMPLATE_SIGNATURE=${DIM_TEMPLATE_SIGNATURE:-$HOME/.dim.template.signature}

#
# Internal configuration.
#

today=`date +%Y-%m-%d`

drm_intel_ssh=ssh://git.freedesktop.org/git/drm-intel
drm_intel_git=git://anongit.freedesktop.org/drm-intel
drm_upstream_git=git://people.freedesktop.org/~airlied/linux
sound_upstream_git=git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git
driver_core_upstream_git=git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core.git
linux_upstream_git=git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

# email aliases
addr_drm_maintainer="Dave Airlie <airlied@gmail.com>"
addr_intel_gfx_maintainer1="Daniel Vetter <daniel.vetter@ffwll.ch>"
addr_intel_gfx_maintainer2="Jani Nikula <jani.nikula@linux.intel.com>"
addr_intel_gfx="intel-gfx@lists.freedesktop.org"
addr_dri_devel="dri-devel@lists.freedesktop.org"
addr_intel_qa1="\"Sun, Yi\" <yi.sun@intel.com>"
addr_intel_qa2="\"Christophe Prigent\" <christophe.prigent@intel.com>"

#
# Command line options.
#

DRY_RUN=
DRY=
FORCE=

function warn_or_fail
{
	if [[ $FORCE ]] ; then
		echo WARNING: $1, but continuing
	else
		echo ERROR: $1, aborting
		exit 1
	fi
}

while getopts df opt; do
	case "$opt" in
		d)
			DRY_RUN=--dry-run
			DRY=echo
			;;
		f)
			FORCE=1
			;;
		*)
			echo "Try 'dim help' for more information."
			exit
	esac
done
shift `expr $OPTIND - 1`

# first positional argument is the subcommand
if [ "$#" = "0" ]; then
    subcommand="help"
else
    subcommand="$1"
    shift
fi

#
# Sanity checks.
#

if [ "$subcommand" != "setup" ]; then
	for d in $DIM_PREFIX $DIM_PREFIX/$DIM_DRM_INTEL $DIM_PREFIX/drm-intel-rerere $DIM_PREFIX/drm-intel-nightly; do
		if [ ! -d $d ]; then
			echo "$d is missing, please check your configuration and/or run dim setup"
			exit 1
		fi
	done
fi

#
# Internal configuration that depends on a sane setup.
#

dim_branches=`(source $DIM_PREFIX/drm-intel-rerere/nightly.conf ; echo $nightly_branches) | \
	xargs -n 1 echo | grep '^origin' | sed -e 's/^origin\///'`

function update_linux_next
{
	cd $DIM_PREFIX/drm-intel-nightly

	# always update drm-intel-fixes
	echo -n "Pushing drm-intel-fixes to for-linux-next-fixes... "
	git push $DRY_RUN origin +origin/drm-intel-fixes:for-linux-next-fixes >& /dev/null
	echo "Done."

	if git merge-base --is-ancestor origin/drm-intel-next-fixes origin/drm-intel-fixes ; then
		# -fixes has caught up to dinf, i.e. we're out of the merge
		# window. Push the next queue.
		echo -n "Out of merge window. Pushing drm-intel-next-queued to for-linux-next... "
		git push $DRY_RUN origin +origin/drm-intel-next-queued:for-linux-next >& /dev/null
		echo "Done."
	else
		# dinf is ahead of -fixes, i.e. drm-next has already closed for
		# the next merge window and we've started to gather new fixes
		# for the current -next cycle. Push dinf

		echo -n "Pushing drm-intel-next-fixes to for-linux-next... "
		git push $DRY_RUN origin +origin/drm-intel-next-fixes:for-linux-next >& /dev/null
		echo "Done."
	fi
}

function check_conflicts
{
	if git diff | grep '\(<<<<<<<\|=======\|>>>>>>>\||||||||\)' ; then
		if [ -n "$1" ]; then
			echo $*
		fi
		exit 1
	fi
	true
}

function update_rerere_cache
{
	cd $DIM_PREFIX/drm-intel-rerere/
	git pull
	cp rr-cache/* $DIM_PREFIX/drm-intel-nightly/.git/rr-cache/ -r
	cd -
}

function update_nightly
{
	local integration_branch=drm-intel-nightly
	local specfile=`mktemp`
	local time="`date --utc +%Yy-%mm-%dd-%Hh-%Mm-%Ss` UTC"
	local first=1

	local rerere=$DIM_PREFIX/drm-intel-rerere

	cd $rerere
	if [[ `git status --porcelain | grep -v "^[ ?][ ?]" | wc -l` -gt 0 ]]; then
		warn_or_fail "-nightly configuration file not commited"
	fi

	echo -n "Updating rerere cache and nightly.conf... "
	update_rerere_cache >& /dev/null
	echo "Done."

	source $rerere/nightly.conf

	cd $DIM_PREFIX/$integration_branch
	if ! git branch | grep $integration_branch | grep '\*' >& /dev/null ; then
		echo "Branch setup for the integration repo is borked"
		exit 1
	fi

	for remote in $(echo $nightly_branches | tr " " "\n" | sed 's|/.*$||g' | sort -u); do
		echo -n "Fetching $remote... "
		# git fetch returns 128 if there's nothing to be fetched
		git fetch $remote >& /dev/null || true
		echo "Done."
	done

	# merge -fixes
	for tree in $nightly_branches; do
		local branch=${tree%:*}
		local sha1=${tree#*:}
		local name=${branch##*/}

		# the : separator is optional
		if [[ $sha1 == $tree ]] ; then
			sha1=
		fi

		echo -n "Merging $branch... "

		if [[ -n $sha1 ]] ; then
			echo -n "Using override sha1: $sha1... "
		else
			sha1=$branch
		fi

		if [ $first == 1 ] ; then
			echo "Reset. Done."
			git reset --hard $sha1 >& /dev/null
			first=0
		elif git merge --rerere-autoupdate --ff-only $sha1 >& /dev/null ; then
			# nothing to do if just fast-forward
			echo "Fast-forward. Done."
			true
		else
			local fixup_file=$rerere/$integration_branch-$name-fixup.patch

			echo $fixup_file > .fixup_file_path

			git merge --rerere-autoupdate --no-commit $sha1 >& /dev/null || true
			if [ -f $fixup_file ] ; then
				echo -n "Applying manual fixup patch for $integration_branch merge... "
				patch -p1 -i $fixup_file
			fi
			check_conflicts "Fail: conflict merging $tree"
			git add -u

			# because we filter out fast-forward merges there will
			# always be something to commit
			git commit --no-edit --quiet
			echo "Done."
		fi

		echo -e "$branch `git rev-parse $sha1`\n\t`git log -1 $sha1 --pretty=format:%s`" >> $specfile
	done

	echo -n "Adding integration manifest $integration_branch: $time... "
	mv $specfile integration-manifest
	git add integration-manifest
	git commit --quiet -m "$integration_branch: $time integration manifest"
	echo "Done."

	echo -n "Pushing $integration_branch... "
	git push $DRY_RUN origin +HEAD >& /dev/null && echo "Done."

	echo -n "Updating rerere cache... "
	cd $rerere
	if git branch | grep rerere-cache | grep '\*' >& /dev/null ; then
		git pull >& /dev/null
		cp $DIM_PREFIX/$integration_branch/.git/rr-cache/* rr-cache -r
		git add *.patch >& /dev/null || true
		git add rr-cache/* > /dev/null
		if git commit -m "$time: $integration_branch rerere cache update" >& /dev/null; then
			echo -n "New commit. "
		else
			echo -n "Nothing changed. "
		fi
		echo -n "Pushing rerere cache... "
		git push $DRY_RUN origin HEAD >& /dev/null && echo "Done."
	else
		echo "Fail: Branch setup for the rerere-cache is borked."
	fi

}

# push branch $1, rebuild nightly. the rest of the arguments are passed to git
# push.
function dim_push
{
	branch=$1
	shift

	assert_branch $branch

	git push $DRY_RUN $DIM_DRM_INTEL_REMOTE $branch "$@"

	update_nightly
	update_linux_next
}

# ensure we're on branch $1, and apply patches. the rest of the arguments are
# passed to git am.
function dim_apply
{
	branch=$1
	shift

	assert_branch $branch

	if [[ -n `git status --porcelain --untracked-files=no` ]] ; then
		echo Repository not clean, aborting
		exit 2
	fi

	git am -3 "$@"
	dim_checkpatch HEAD
	git commit --amend &
}

function magic_patch
{
	if [[ "$1" = "-a" ]]; then
		cd `cat ~/.dim-last-path`
	fi

	local conflict_files=`patch -p1 | grep "saving rejects" | sed -e "s/.*saving rejects to file \(.*\)/\1/"`

	if [[ $conflict_files != "" ]] ; then
		echo conflicts found!
	fi

	for file in $conflict_files ; do
		echo wiggling in ${file%.rej}:
		#cat $file
		rm -f ${file%.rej}.porig
		wiggle -r ${file%.rej} $file || true
	done
}

function dim_cd
{
	local path

	if [[ -d $DIM_PREFIX/$1 ]] ; then
		path=$DIM_PREFIX/$1
	else
		path=$DIM_PREFIX/$DIM_DRM_INTEL
	fi

	echo $path > ~/.dim-last-path
	cd $path
}

function dim_co
{
	dim_cd $1
	git checkout $1
}

function check_repo_clean
{
	cd $1
	if ! git diff-index --quiet HEAD ; then
		echo $2 repo not clean, aborting
		exit 1
	fi

}

# $1 is the git sha1 to check
function dim_checkpatch
{
	local commit=$1

	git --no-pager log --oneline -1 $commit
	git show $commit --pretty=email | scripts/checkpatch.pl -q --strict - || true
	if git show $commit | grep '^\+.*\WBUG' > /dev/null; then
		warn_or_fail "New BUG macro added"
	fi
	git show $commit | grep '^\+.*drm_i915_private_t' > /dev/null && echo "WARNING: New drm_i915_private_t added" || true
}

function dim_checkrange
{
	local range

	if [ -z "$1" ]; then
		range="HEAD^..HEAD"
	elif [ -n "`echo $1 | grep '\.\.'`" ]; then
		range="$1"
	else
		range="$1..HEAD"
	fi

	for commit in $(git rev-list --reverse $range); do
		dim_checkpatch $commit || true
	done
}

function prep_pull_mail_greetings
{
	if [ -r $DIM_TEMPLATE_HELLO ]; then
		cat $DIM_TEMPLATE_HELLO
	else
		cat <<-EOF
		Hi Dave,

		EOF
	fi
}

function prep_pull_mail_signature
{
	if [ -r $DIM_TEMPLATE_SIGNATURE ]; then
		cat $DIM_TEMPLATE_SIGNATURE
	else
		cat <<-EOF

		Cheers, Daniel


		EOF
	fi
}

# print pull mail overview based on tags in $@, if any
# without tags, print a reminder
function prep_pull_mail_overview
{
	if [ "$#" = "0" ]; then
		echo "*** insert pull request overview here ***"
	else
		for tag in $@ ; do
			local obj=`git rev-parse $tag`
			if [[ `git cat-file -t $obj` == "tag" ]] ; then
				echo $tag:
				git cat-file -p $obj | tail -n+6
			fi
		done
	fi
}

# prepare a pull request mail
# $@: tags, if any, to extract into the pull request overview
function prep_pull_mail
{
	prep_pull_mail_greetings > ~/tmp/dim-pull-request
	prep_pull_mail_overview $@ >> ~/tmp/dim-pull-request
	prep_pull_mail_signature >> ~/tmp/dim-pull-request
}

function create_workdir
{
	cd $DIM_PREFIX
	local branches

	if [[ "x$1" = "x" ]]; then
		echo "usage: $0 $subcommand branch|all"
		exit 1
	elif [[ "$1" = "all" ]] ; then
		branches=$dim_branches
	else
		branches=$1
	fi

	for branch in $branches ; do
		if [[ -d $branch ]] ; then
			continue;
		fi

		echo Creating separate workdir for $branch

		$DRY git-new-workdir src $branch $branch
	done
}

# dim_pull_request branch upstream
function dim_pull_request
{
	branch=$1
	upstream=$2

	if [ "$branch" != "drm-intel-next" ]; then
		assert_branch $branch
	else
		cd $DIM_PREFIX/$DIM_DRM_INTEL
	fi

	git fetch ${upstream%%/*} >& /dev/null || true
	echo "Using $upstream as the upstream"

	if [ "$branch" = "drm-intel-next" ]; then
		# drm-intel-next pulls have been tagged using dim update-next
		drm_intel_next_tags=`git log $DIM_DRM_INTEL_REMOTE/drm-intel-next ^$upstream --decorate | grep "(.*tag: drm-intel-next-" | sed -e "s/^.*(.*tag: \(drm-intel-next-[^ ,]*\).*)$/\1/"`
		prep_pull_mail $drm_intel_next_tags
		tag=`git describe --all --exact $DIM_DRM_INTEL_REMOTE/drm-intel-next`
	else
		tag=$branch-$today
		$DRY git tag -f $tag $DIM_DRM_INTEL_REMOTE/$branch
		$DRY git push -f $DIM_DRM_INTEL_REMOTE $tag
		prep_pull_mail
	fi

	git request-pull $upstream $drm_intel_git $tag >> ~/tmp/dim-pull-request
	$DRY $DIM_MUA -s "[PULL] $branch" \
		-i ~/tmp/dim-pull-request \
		-c "$addr_intel_gfx" \
		-c "$addr_dri_devel" \
		-c "$addr_intel_gfx_maintainer1" \
		-c "$addr_intel_gfx_maintainer2" \
		"$addr_drm_maintainer"
}

function setup_dim
{
	if [ ! -d $DIM_PREFIX ]; then
		echo "please set up your repository directory with:"
		echo "    mkdir -p $DIM_PREFIX"
		echo "or update your configuration"
		exit 1
	fi
	cd $DIM_PREFIX

	if [ ! -d $DIM_PREFIX/$DIM_DRM_INTEL ]; then
		echo "please set up your maintainer linux repository at $DIM_PREFIX/$DIM_DRM_INTEL with:"
		echo "    cd $DIM_PREFIX"
		echo "    git clone $linux_upstream_git $DIM_DRM_INTEL"
		echo "or update your configuration."
		exit 1
	fi
	cd $DIM_DRM_INTEL
	if ! git remote -v | grep "^origin[[:space:]]" | grep $linux_upstream_git > /dev/null; then
		echo "please set up remote origin for $linux_upstream_git"
		exit 1
	fi
	if ! git remote -v | grep "^$DIM_DRM_INTEL_REMOTE[[:space:]]" | grep $drm_intel_ssh > /dev/null; then
		echo "please set up remote $DIM_DRM_INTEL_REMOTE for $drm_intel_ssh with:"
		echo "    git remote add $DIM_DRM_INTEL_REMOTE $drm_intel_ssh"
		echo "or update your configuration."
		exit 1
	fi
	if ! git remote -v | grep "^$DIM_DRM_UPSTREAM_REMOTE[[:space:]]" | grep $drm_upstream_git > /dev/null; then
		echo "please set up remote $DIM_DRM_UPSTREAM_REMOTE for $drm_upstream_git with:"
		echo "    git remote add $DIM_DRM_UPSTREAM_REMOTE $drm_upstream_git"
		echo "or update your configuration."
		exit 1
	fi
	cd ..

	if [ ! -d maintainer-tools ]; then
		git clone --reference=$DIM_PREFIX/$DIM_DRM_INTEL/.git $drm_intel_ssh maintainer-tools
	fi
	cd maintainer-tools
	git config remote.origin.url $drm_intel_ssh
	echo "$DIM_PREFIX/$DIM_DRM_INTEL/.git/objects" > .git/objects/info/alternates
	git repack -a -d -l
	if ! git branch | grep maintainer-tools > /dev/null ; then
		git checkout -t origin/maintainer-tools
	fi
	cd ..

	if [ ! -d drm-intel-rerere ]; then
		git clone --reference=$DIM_PREFIX/$DIM_DRM_INTEL/.git $drm_intel_ssh drm-intel-rerere
	fi
	cd drm-intel-rerere
	git config remote.origin.url $drm_intel_ssh
	echo "$DIM_PREFIX/$DIM_DRM_INTEL/.git/objects" > .git/objects/info/alternates
	git repack -a -d -l
	if ! git branch | grep rerere-cache > /dev/null ; then
		git checkout -t origin/rerere-cache
	fi
	cd ..

	if [ ! -d drm-intel-nightly ]; then
		git clone --reference=$DIM_PREFIX/$DIM_DRM_INTEL/.git $drm_intel_ssh drm-intel-nightly
	fi
	cd drm-intel-nightly
	mkdir -p .git/rr-cache
	git config remote.origin.url $drm_intel_ssh
	echo "$DIM_PREFIX/$DIM_DRM_INTEL/.git/objects" > .git/objects/info/alternates
	git repack -a -d -l
	if ! git branch | grep drm-intel-nightly > /dev/null ; then
		git checkout -t origin/drm-intel-nightly
	fi
	if git remote | grep drm-upstream > /dev/null ; then
		git config remote.drm-upstream.url $drm_upstream_git
	else
		git remote add drm-upstream $drm_upstream_git
	fi
	if git remote | grep sound-upstream > /dev/null ; then
		git config remote.sound-upstream.url $sound_upstream_git
	else
		git remote add sound-upstream $sound_upstream_git
	fi
	if git remote | grep driver-core-upstream > /dev/null ; then
		git config remote.driver-core-upstream.url $driver_core_upstream_git
	else
		git remote add driver-core-upstream $driver_core_upstream_git
	fi
}

function assert_branch
{
	local branch=$1

	dim_cd $branch

	if git branch | grep $branch | grep '\*' ; then
		return 0
	else
		echo "You're on the wrong branch, expected $branch in $PWD"
		return 1
	fi
}

case "$subcommand" in
	setup)
		setup_dim
		;;
	nightly-forget)
		cd $DIM_PREFIX/drm-intel-nightly
		git fetch origin >& /dev/null
		git reset --hard origin/drm-intel-next-queued >& /dev/null
		git merge origin/drm-intel-fixes
		git rerere forget
		;;
	update-branches|ub)
		cd $DIM_PREFIX/$DIM_DRM_INTEL
		git fetch $DIM_DRM_INTEL_REMOTE
		check_repo_clean $DIM_PREFIX/$DIM_DRM_INTEL Kernel

		for branch in $dim_branches ; do
			dim_co $branch
			if git diff --quiet $DIM_DRM_INTEL_REMOTE/$branch; then
				$DRY git rebase
			else
				$DRY git rebase -i
			fi
		done
		dim_co drm-intel-next
		$DRY git reset --hard $DIM_DRM_INTEL_REMOTE/drm-intel-next
		# TODO: Restore -nightly merge state from the rerere-cache
		# branch
		update_rerere_cache
		;;
	create-workdir)
		create_workdir $1
		;;
	for-each-workdirs|fw)
		cd $DIM_PREFIX/$DIM_DRM_INTEL
		$@
		for branch in $dim_branches ; do
			if [[ -d $DIM_PREFIX/$branch ]] ; then
				cd $DIM_PREFIX/$branch
				$@
			fi
		done
		;;
	rebuild-nightly)
		update_nightly
		;;
	cat-to-fixup)
		cd $DIM_PREFIX/drm-intel-nightly
		cat > `cat .fixup_file_path`
		;;
	push-branch)
		if [[ "x$1" = "x" ]]; then
			echo "usage: $0 $subcommand branch"
			exit 1
		fi
		dim_push "$@"
		;;
	push-queued|pq)
		dim_push drm-intel-next-queued "$@"
		;;
	push-next-fixes|pnf)
		dim_push drm-intel-next-fixes "$@"
		;;
	push-fixes|pf)
		dim_push drm-intel-fixes "$@"
		;;
	co)
		dim_co drm-intel-next-queued
		;;
	cof)
		dim_co drm-intel-fixes
		;;
	conf)
		dim_co drm-intel-next-fixes
		;;
	apply-branch|ab|sob)
		dim_apply "$@"
		;;
	apply-queued|aq)
		dim_apply drm-intel-next-queued "$@"
		;;
	apply-fixes|af)
		dim_apply drm-intel-fixes "$@"
		;;
	apply-next-fixes|anf)
		dim_apply drm-intel-next-fixes "$@"
		;;
	apply-resolved|ar)
		make -j 20 && git add -u && git am --resolved
		dim_checkpatch HEAD
		git commit --amend &
		;;
	apply-igt|ai)
		cd ~/xorg/intel-gpu-tools/
		git am --whitespace=fix -3 -s
		;;
	magic-patch|mp)
		magic_patch "$@"
		;;
	magic-rebase-resolve|mrr)
		git diff HEAD | patch -p1 -R
		cat .git/rebase-merge/patch | dim mp
		make -j 20
		git add -u
		git rebase --continue
		;;
	tc)
		cd $DIM_PREFIX/$DIM_DRM_INTEL
		git tag --contains $1 | grep ^v | sort -V | head -n 1
		;;
	check-patch|cp)
		dim_checkrange $@
		;;
	cherry-pick)
		if [[ "x$1" = "x" ]]; then
			echo "usage: $0 $subcommand commit-ish"
			exit 1
		fi
		sha=`git rev-parse $1`
		sha_short=${sha:0:8}

		# need latest -nightly
		git fetch $DIM_DRM_INTEL_REMOTE
		echo Possible fixup patches for your cherry-pick:
		git log --grep=$sha_short --pretty=oneline $sha..$DIM_DRM_INTEL_REMOTE/drm-intel-nightly
		$DRY git cherry-pick $1
		;;
	pull-request)
		if [[ "x$1" = "x" || "x$2" = "x" ]]; then
			echo "usage: $0 $subcommand branch upstream"
			exit 1
		fi
		dim_pull_request $*
		;;
	pull-request-next)
		upstream=${1:-$DIM_DRM_UPSTREAM_REMOTE/drm-next}
		dim_pull_request drm-intel-next $upstream
		;;
	pull-request-fixes)
		upstream=${1:-origin/master}
		dim_pull_request drm-intel-fixes $upstream
		;;
	pull-request-next-fixes)
		upstream=${1:-$DIM_DRM_UPSTREAM_REMOTE/drm-next}
		dim_pull_request drm-intel-next-fixes $upstream
		;;
	update-next)
		assert_branch drm-intel-next-queued

		git fetch $DIM_DRM_INTEL_REMOTE
		if ! git branch --merged $DIM_DRM_INTEL_REMOTE/drm-intel-nightly | grep drm-intel-fixes &> /dev/null ; then
			echo "drm-intel-fixes not merged into -nigthly, please update!"
			exit 2
		fi
		if ! git branch --merged $DIM_DRM_INTEL_REMOTE/drm-intel-nightly | grep drm-intel-next-queued &> /dev/null ; then
			echo "drm-intel-next-queued not merged into -nigthly, please update!"
			exit 2
		fi

		driver_date=`date +%Y%m%d`
		$DRY sed -i -e "s/^#define DRIVER_DATE.*\"[0-9]*\"$/#define DRIVER_DATE\t\t\"$driver_date\"/" \
			drivers/gpu/drm/i915/i915_drv.h
		$DRY git add drivers/gpu/drm/i915/i915_drv.h
		echo -e "drm/i915: Update DRIVER_DATE to $driver_date\n\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>" | \
			git commit -s -F -

		gitk drm-intel-next-queued ^$DIM_DRM_UPSTREAM_REMOTE/drm-next &

		git push $DRY_RUN $DIM_DRM_INTEL_REMOTE drm-intel-next-queued:drm-intel-next
		tag=drm-intel-next-$today
		$DRY git tag -f -a $tag $DIM_DRM_INTEL_REMOTE/drm-intel-next
		git push $DRY_RUN -f $DIM_DRM_INTEL_REMOTE $tag

		echo "Updating -testing to latest -nightly"
		git push $DRY_RUN $DIM_DRM_INTEL_REMOTE +$DIM_DRM_INTEL_REMOTE/drm-intel-nightly:drm-intel-testing
		$DRY git tag -f drm-intel-testing-$today $DIM_DRM_INTEL_REMOTE/drm-intel-testing
		$DRY git push -f $DIM_DRM_INTEL_REMOTE drm-intel-testing-$today

		cat > ~/tmp/test-request <<-HERE
		Hi all,

		New -testing cycle with cool stuff:
		HERE
		obj=`git rev-parse $tag`
		if [[ `git cat-file -t $obj` == "tag" ]] ; then
			git cat-file -p $obj | tail -n+6 >> ~/tmp/test-request
		else
			echo "<tag doesn't contain a changelog overview, fix this>" >> ~/tmp/test-request
		fi
		cat >> ~/tmp/test-request <<-HERE

		Happy testing!

		Cheers, Daniel
		HERE

		$DRY $DIM_MUA -s "Updated drm-intel-testing" \
			-i ~/tmp/test-request \
			-c "$addr_intel_gfx" \
			-c "$addr_intel_gfx_maintainer1" \
			-c "$addr_intel_gfx_maintainer2" \
			"$addr_intel_qa1" \
			"$addr_intel_qa2"
		;;
	tag-next)
		cd $DIM_PREFIX/$DIM_DRM_INTEL
		git fetch $DIM_DRM_INTEL_REMOTE

		if [ $(git rev-parse drm-intel-next) == $(git rev-parse drm-intel-next@{u}) ] ; then
			echo "Tagging current drm-intel-next"

			tag=drm-intel-next-$today
			$DRY git tag -f $tag $DIM_DRM_INTEL_REMOTE/drm-intel-next
			git push $DRY_RUN -f $DIM_DRM_INTEL_REMOTE $tag
		else
			echo "drm-intel-next not up-to-date, aborting"
			exit
		fi

		;;
	create-branch)
		if [[ "x$1" = "x" ]]; then
			echo "usage: $0 $subcommand branch [commit-ish]"
			exit 1
		fi
		branch=$1
		if [[ "x$2" = "x" ]]; then
			start=HEAD
		else
			start=$2
		fi

		cd $DIM_PREFIX/$DIM_DRM_INTEL

		$DRY git branch $branch $start
		git push $DRY_RUN $DIM_DRM_INTEL_REMOTE +$branch --set-upstream
		cd $DIM_PREFIX/drm-intel-rerere
		$DRY echo "nightly_branches=\"\$nightly_branches origin/$branch\"" \
			>> nightly.conf
		$DRY git add nightly.conf
		$DRY git commit --quiet -m "Adding $branch to -nightly"
		;;
	remove-branch)
		if [[ "x$1" = "x" ]]; then
			echo "usage: $0 $subcommand branch"
			exit 1
		fi
		branch=$1

		cd $DIM_PREFIX/$DIM_DRM_INTEL

		if ! $DRY git branch -d $branch ; then
			warn_or_fail "Can't remove $branch in working repo"
		fi

		if [[ -d $DIM_PREFIX/$branch ]] ; then
			rm -R $DIM_PREFIX/$branch
		fi

		cd $DIM_PREFIX/drm-intel-nightly
		git push $DRY_RUN origin --delete $branch
		$DRY git fetch origin --prune
		cd $DIM_PREFIX/drm-intel-rerere
		full_branch="origin/$branch"
		$DRY sed -e "/${full_branch//\//\\\/}/d" -i nightly.conf
		$DRY git add nightly.conf
		$DRY git commit --quiet -m "Deleted $branch and removed from -nightly"
		;;
	checker)
		rm drivers/gpu/drm/i915/*.o &> /dev/null || true
		rm drivers/gpu/drm/i915/*.ko &> /dev/null || true
		make C=1 drivers/gpu/drm/i915/i915.ko
		;;
	*)
		if hash rst2man 2>/dev/null; then
			renderer=rst2man
			pager="man -l -"
		else
			renderer=cat
			pager=${PAGER:-cat}
		fi
		$renderer <<HERE | $pager
=====
 dim
=====

---------------------------
drm-intel maintainer script
---------------------------

:Author: Daniel Vetter <daniel.vetter@ffwll.ch>
:Author: Jani Nikula <jani.nikula@intel.com>
:Date: 2014-05-15
:Copyright: 2012-2015 Intel Corporation
:Manual section: 1
:Manual group: maintainer tools

SYNOPSIS
========

**dim** [*option* ...] *command*

DESCRIPTION
===========

drm-intel maintainer script.

Branch Model
------------

The dim flow has 3 main development branches:

- drm-intel-next-queued for feature work. This branch gets regularly pushed to
  drm-intel-next and tagged and then sent on to the upstream drm-next branch
  using *update-next*.  The cut-off for the last pull request to drm-next is
  around -rc5. After that point patches in drm-intel-next-queued already aim at
  the next but one and not the next merge window.

- drm-intel-next-fixes is to collect fixes for the current merge window after
  the -rc5 feature cut-off in drm-next.

- drm-intel-fixes is for fixes for the current -rc1 kernel. This is separate
  from drm-intel-next-fixes since the merge window feature cutoff at -rc5 is a
  few weeks ahead of the final release of the previous kernel.

  There's separate tracking branches for inclusion into linux-next to make sure
  that the feature work in drm-intel-next-queued aimed for the next but one
  merge window doesn't cause unecassary conflicts in linux-next - in that case
  only drm-intel-next-fixes is included in linux-next. The switchover happens
  when drm-intel-fixes has caught up (in git terms: drm-intel-next-fixes is
  direct ancestor of drm-intel-fixes). Therefore only roll drm-intel-fixes
  forward once -rc1 is released

In addition there's 2 permanent topic branches:

- topic/drm-misc carries core drm patches aimed at the next merge window.

- topic/drm-fixes carries core drm fixes for the current -rc kernels.

Additional topic branches are created as needed using *create-branch* and
*remove-branch*.

OPTIONS
=======

-f		Ignore some error conditions.
-d		Dry run.

COMMANDS
========

setup *prefix*
--------------
Setup git maintainer branches in the given prefix.

nightly-forget
--------------
Forget git rerere solutions for nightly merges in case they
contain a bogus merge resolution.

update-branches
---------------
Updates all maintainer branches. Only needs to be run to synchronize branches
between different machines (or maintainers fwiw). As long a given branch is
always maintained from the same machine, even if different branches are
maintained on different machines (by different maintainers), there's no need to
run this command.

rebuild-nightly
---------------
Rebuilds the nightly branch. Useful when ad-hoc trees are
included in -nightly.

cat-to-fixup
------------

Pipes stdin into the fixup patch file for the current -nightly merge.

push-branch branch [*git push arguments*]
-----------------------------------------

push-fixes|pf [*git push arguments*]
------------------------------------

push-next-fixes|pnf [*git push arguments*]
------------------------------------------

push-queued|pq [*git push arguments*]
-------------------------------------

Updates the named branch, or drm-intel-fixes, drm-intel-next-fixes or the
drm-intel-next-queued branch respectively. Complains if that's not the current
branch, assuming that patches got merged to the wrong branch. After pushing also
updates linux-next and drm-intel-nightly branches.

co
--

cof
---

conf
----
Checks out the drm-intel-fixes branch, dinf or dinq respectively for merging
patches.

apply-branch|ab|sob branch [*git am arguments*]
-----------------------------------------------
Applys a patch to the given branch, complaining if it is not
checked out yet.

apply-fixes|af [*git am arguments*]
-----------------------------------

apply-next-fixes|anf [*git am arguments*]
-----------------------------------------

apply-queued|aq [*git am arguments*]
------------------------------------
Applies a patch to -fixes, -next-fixes or -next-queued respectively, complains
if it's not the right branch. Additional arguments are passed to git am.

magic-patch|mp [-a]
-------------------
Apply a patch using patch and then wiggle in any conflicts. When passing the
option -a automatically changes the working directory into the git repository
used by the last previous branch-specific command. This is useful with the
per-branch workdir model.

magic-rebase-resolve|mrr
------------------------
Tries to resolve a rebase conflict by first resetting the tree
and the using the magic patch tool. Then builds the tree, adds
any changes with git add -u and continues the rebase.

cd
--
Changes the working directory into the git repository used by the last previous
branch-specific command. This is implemented as a bash-function to make it
useful in interactive shells and scripts. Only available when the bash
completion is sourced.

apply-resolved|ar
-----------------
Compile-test the current tree and if successfully resolve a
confilicted git am. Also runs the patch checker afterwards.

apply-igt|ai
------------
Apply a patch to the i-g-t repository.

tc *commit-ish*
---------------
Prints the linux kernel tag which contains the supplied commit-ish

check-patch|cp [*commit-ish* [.. *commit-ish*]]
-----------------------------------------------
Runs the given commit range commit-ish..commit-ish through the check tools. If
no commit-ish is passed, defaults to HEAD^..HEAD. If one commit-ish is passed
instead of a range, the range commit-ish..HEAD is used.

cherry-pick *commit-ish* [*git cherry-pick arguments*]
------------------------------------------------------

Improved git cherry-pick version which also scans drm-intel-nightly for any
mentions of the cherry-picked commit. Should be used when cherry-pick from -next
to -fixes to make sure all fixups are picked, too. In dry-run mode/-d only the
patch list is generated.

pull-request *branch* *upstream*
--------------------------------
Fetch the *upstream* remote to make sure it's up-to-date, create and push a date
based tag for the *branch*, generate a pull request template with the specified
*upstream*, and finally start \$DIM_MUA with the template with subject and
recipients already set.

Since the tag for the *branch* is date based, the pull request can be
regenerated with the same commands if something goes wrong.

pull-request-fixes [*upstream*]
-------------------------------
This is a special case of **pull-request**, with *drm-intel-fixes* as the
branch and *origin/master* as the default upstream.

pull-request-next-fixes [*upstream*]
------------------------------------
This is a special case of **pull-request**, with *drm-intel-next-fixes* as
the branch and *\$DRM_UPSTREAM/drm-next* as the default upstream.

pull-request-next [*upstream*]
------------------------------
This is similar to **pull-request**, but for feature pull requests, with
*drm-intel-next* as the branch and *\$DRM_UPSTREAM/drm-next* as the default
upstream.

The difference to **pull-request** is that this command does not generate a
tag; this must have been done previously using **update-next**. This also means
that the pull request can be regenerated with the same commands if something
goes wrong.

update-next
-----------
Pushes out the latest dinq to drm-intel-next and tags it. Also
pushes out the latest nightly to drm-intel-testing. For an
overview a gitk view of the currently unmerged feature pile is
opened.

Also checks that the drm-intel-fixes|-next-queued are fully
merged into -nightly to avoid operator error.

tag-next
--------

Pushes a new tag for the current drm-intel-next state after checking that the
remote is up-to-date. Useful if drm-intel-next has been changed since the last
run of the update-next command (e.g. to apply a hotfix before sending out the
pull request).

checker
-------
Run sparse on the kernel.

create-branch *branch* [*commit-ish*]
-------------------------------------

Create a new topic branch with the given name. Note that topic/ is not
automatically prepended. The branch starts at HEAD or the given commit-ish.

remove-branch *branch*
----------------------

Remove the given topic branch.

create-workdir *branch*|all
---------------------------

Create a separate workdir for the branch with the given name (requires that
git-new-workdir from git-core contrib is installed), or for all branches if
"all" is given.

for-each-workdir|fw *command*
-----------------------------

Run the given command in all active workdirs including the main repository under
\$DIM_DRM_INTEL.

help
----
Show this help. Install **rst2man(1)** for best results.

ENVIRONMENT
===========

DIM_CONFIG
----------
Path to the dim configuration file, \$HOME/.dimrc by default, which is sourced
if it exists. It can be used to set other environment variables to control dim.

DIM_PREFIX
----------
Path prefix for kernel repositories.

DIM_DRM_INTEL
-------------
The main maintainer repository under \$DIM_PREFIX.

DIM_DRM_INTEL_REMOTE
--------------------
Name of the $drm_intel_ssh remote within \$DIM_DRM_INTEL.

DIM_DRM_UPSTREAM_REMOTE
-----------------------
Name of the $drm_upstream_git remote within \$DIM_DRM_INTEL.

DIM_MUA
-------
Mail user agent. Must support the following subset of **mutt(1)** command line
options: \$DIM_MUA [-s subject] [-i file] [-c cc-addr] to-addr [...]

DIM_TEMPLATE_HELLO
------------------
Path to a file containing a greeting template for pull request mails.

DIM_TEMPLATE_SIGNATURE
----------------------
Path to a file containing a signature template for pull request mails.

HERE
		exit 0
		;;
esac
